= Corefines
Jakub Jirutka <https://github.com/jirutka[@jirutka]>
:page-layout: base
:idprefix:
ifdef::env-github[:idprefix: user-content-]
:idseparator: -
:source-language: ruby
:language: {source-language}
// custom
:gem-name: corefines
:gh-name: jirutka/{gem-name}
:gh-branch: master
:badge-style: flat
:doc-base-url: http://www.rubydoc.info/github/jirutka/corefines/Corefines

image:https://img.shields.io/travis/{gh-name}/{gh-branch}.svg?style={badge-style}[Build Status, link="https://travis-ci.org/{gh-name}"]
image:https://img.shields.io/codeclimate/coverage/github/{gh-name}.svg?style={badge-style}[Test Coverage, link="https://codeclimate.com/github/{gh-name}"]
image:https://img.shields.io/codeclimate/github/{gh-name}.svg?style={badge-style}[Code Climate, link="https://codeclimate.com/github/{gh-name}"]
image:https://inch-ci.org/github/{gh-name}.svg?branch={gh-branch}&style={badge-style}[Inline docs, link="http://inch-ci.org/github/{gh-name}"]
image:https://img.shields.io/gem/v/{gem-name}.svg?style={badge-style}[Gem Version, link="https://rubygems.org/gems/{gem-name}"]
image:https://img.shields.io/badge/yard-docs-blue.svg?style={badge-style}[Yard Docs, link="http://www.rubydoc.info/github/{gh-name}/frames"]

Corefines is a collection of general purpose _refinements_ for extending the core capabilities of Ruby’s built-in classes.
It also provides a compatibility mode for older Ruby versions and alternative Ruby implementations that don’t support refinements (yet).


== Why refinements?

TODO


== Installation

Add this line to your application’s Gemfile:

[source]
gem 'corefines'

or to your gemspec:

[source]
s.add_runtime_dependency 'corefines'

and then execute:

[source, sh]
$ bundle install


== Using

First, you must require `corefines` prior using:

[source]
require 'corefines'

This will _not_ activate any extensions (just register them), even when running in compatibility mode.
Extensions (refinements) are activated selectively with the method http://ruby-doc.org/core-2.2.0/Module.html#method-i-using[`using`].

Refinements are organized into modules by class which they refine, and further into submodules for individual methods.
When an extension refines multiple classes, then it’s included in a module named after their nearest common ancestor (superclass).

[source, plain]
Corefines::<CLASS>::<METHOD>

A single extension can be imported into the current scope classically, e.g.:

[source]
using Corefines::Hash::MapSend

or preferably using its “alias”:

[source]
using Corefines::Hash::map_send

If you want to include all extensions for the class, then you can just import the parent module, e.g.:

[source]
using Corefines::Hash

But more often you want to include multiple extensions for the class, but not all of them, e.g.:

[source]
using Corefines::Hash::map_send
using Corefines::Hash::+

this can be abbreviated to:

[source]
using Corefines::Hash[:map_send, :+]

Refinements can be activated (with `using`) at top-level (per file), inside a class, module or a method.


== Compatibility mode

TODO


== List of refinements

* {doc-base-url}/Array[Array]
** {doc-base-url}/Array/IndexBy[#index_by]
** {doc-base-url}/Array/MapSend[#map_send]
** {doc-base-url}/Array/Wrap[.wrap]
* {doc-base-url}/Hash[Hash]
** {doc-base-url}/Hash/MapSend[#map_send]
** {doc-base-url}/Hash/OpPlus[#+]
* {doc-base-url}/Module[Module]
** {doc-base-url}/Module/AliasClassMethod[#alias_class_method]
* {doc-base-url}/Object[Object]
** {doc-base-url}/Object/Blank[#blank?]
** {doc-base-url}/Object/Blank[#presence]
** {doc-base-url}/Object/Else[#else]
** {doc-base-url}/Object/InstanceValues[#instance_values]
** {doc-base-url}/Object/Then[#then]
** {doc-base-url}/Object/ThenIf[#then_if]
** {doc-base-url}/Object/Try[#try]
** {doc-base-url}/Object/Try[#try!]
* {doc-base-url}/Set[Set]
** {doc-base-url}/Set/MapSend[#map_send]
* {doc-base-url}/String[String]
** {doc-base-url}/String/Concat[#concat]
** {doc-base-url}/String/Unindent[#unindent] (alias `#strip_heredoc`)
* {doc-base-url}/Symbol[Symbol]
** {doc-base-url}/Symbol/OpTilde[#~]


== Acknowledgement

Most of the extension methods are based on, or highly inspired from:

* https://github.com/rails/rails/tree/master/activesupport[Active Support (Ruby extensions)]
* https://github.com/rubyworks/facets[Ruby Facets]

Very useful articles about refinements and how to “trick” them:

* https://www.new-bamboo.co.uk/blog/2014/02/05/refinements-under-the-knife/[
Refinements under the knife] by https://github.com/leemachin[@leemachin]
* http://qiita.com/joker1007/items/68d066a12bc763bd2cb4[Refinement関係の小技とできない事をまとめてみた] by https://github.com/joker1007[@joker1007]


== Contributing

. Fork it.
. Create your feature branch (`git checkout -b my-new-feature`).
. Commit your changes (`git commit -am 'Add some feature'`).
. Push to the branch (`git push origin my-new-feature`).
. Create a new Pull Request.


== License

This project is licensed under http://opensource.org/licenses/MIT/[MIT License].
For the full text of the license, see the link:LICENSE[LICENSE] file.
